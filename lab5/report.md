# Lab5实验报告
**PB18111757 陈金宝**
## 一、	Tomasulo算法模拟器

初始时设置指令和延迟，如下:

![](./media/inst.png)

### 1.

周期为2时:

![](./media/cycle-2.png)

此时两条load指令均已经发射。两条load指令分别使用了Load1和Load2部件。其中第一条load指令已经进入执行阶段，第二条load指令刚刚发射，还未进入执行阶段，未得到load所需的地址。

周期为3时:

![](./media/cycle-3.png)

此时load2进入执行阶段，获取要load的memory地址，load1取得memory中的值。

### 2.

乘法开始时的模拟器状态:

![](./media/mult.png)

此时为第6个周期，MULT.D指令开始执行。相比第5个周期，发生的改动有:MULT.D、SUB.D指令进入执行阶段、ADD.D指令发射。寄存器状态中F6的Qi变为add2，保留站中的add2被ADD.D指令占用。

### 3.

因为此时存在RAW相关。MULT.D所需的F2（由load获取）还未就绪。此时MULT.D在等待LOAD将对应的F2写入。

### 4.

周期为15时：

![](./media/cycle-15.png)

此时MULT.D执行完毕。

周期为16时:

![](./media/cycle-16.png)

此时MULT.D写结果，并释放所占用的Mult1。F0的寄存器状态经计算为$M5=M2 \times R [F4]$

### 5.

![](./media/cycle-57.png)

如图，最后一条指令写CBD时为第57周期。此时指令执行完毕。

## 二、	多cache一致性算法-监听法

### 1.

| **所进行的访问** | **是否发生了替换？** | **是否发生了写回？** | **监听协议进行的操作与块状态改变**                           |
| ---------------- | -------------------- | -------------------- | ------------------------------------------------------------ |
| CPU A读第五块    | 否                   | 否                   | 将第5块从存储器读入到CacheA，状态设置为共享                  |
| CPU B读第五块    | 否                   | 否                   | 将第5块从存储器读入到CacheA，状态设置为共享                  |
| CPU C读第五块    | 否                   | 否                   | 将第5块从存储器读入到CacheA，状态设置为共享                  |
| CPU B写第五块    | 否                   | 否                   | 写命中，根据监听协议此时A、C中的块5状态改为无效，B中的块5状态为独占 |
| CPU D读第五块    | 否                   | 是                   | B中的块5写回到存储器，状态设置为共享。且D读入块5，状态设置为共享。 |
| CPU B写第21块    | 是                   | 否                   | B中块5被块21替换，状态设置为独占。                           |
| CPU A写第23块    | 否                   | 否                   | 将第23块从存储器读入到CacheA，状态设置为独占                 |
| CPU C写第23块    | 否                   | 是                   | 写不命中，根据监听协议此时A中的块23写回到存储器，状态设置为无效，C读入块23并写，状态设置为独占。 |
| CPU B读第29块    | 是                   | 是                   | 读不命中，B中块21被写回存储器。之后读入块29替换块21。状态设置为共享。 |
| CPU B写第5块     | 是                   | 否                   | 写不命中，根据监听协议，B读入块5替换掉块29，状态设置为独占。D中的块5状态设置为无效。 |

执行完后的状态如下:
![](./media/cache-msi.png)

## 三、多cache一致性算法-目录法

### 1.

| **所进行的访问** | **监听协议进行的操作与块状态改变**                           |
| ---------------- | ------------------------------------------------------------ |
| CPU A读第6块     | A向本地宿主发送读不命中(A,6)消息，宿主收到请求将块6传送给本地结点，状态设置为共享。共享集合为{A}。 |
| CPU B读第6块     | 本地向宿主结点发送读不命中(B,6)消息，宿主将块传送给本地结点，共享集合为{A,B}，状态为共享 |
| CPU D读第6块     | 本地向宿主结点发送读不命中(D,6)消息，宿主将块传送给本地结点，共享集合为{A,B,D}，状态为共享 |
| CPU B写第6块     | 本地向宿主结点发送写命中(B,6)消息，宿主向远程结点A、D发送作废(6)消息。A、D将块状态设置为无效。B将块6状态设置为独占。目录将块6状态设置为独占，共享集合为{B} |
| CPU C读第6块     | 本地向宿主结点发送读不命中(C,6)消息，宿主向远程结点发送数据块6的消息(读请求)，远程结点将数据块6传送给宿主结点，宿主结点将数据块6传送给本地结点。此时状态均设置为共享，共享集合为{B,C} |
| CPU D写第20块    | 本地向宿主结点发送写不命中(D,20)消息，宿主将数据库传送给本地。此时块20状态均为独占，共享集合为{D} |
| CPU A写第20块    | 本地向宿主结点发送写不命中(A,20)消息，宿主给远程结点D发送取并作废(20)的消息，远程将数据块传送给宿主结点，将CacheD中的块20设为无效。宿主将块20传送给本地结点。状态均为独占。共享集合为{A} |
| CPU D写第6块     | 本地向宿主结点发送写不命中(D,6)消息，宿主向远程结点B、C发送作废(6)的消息。B、C将块6设置为无效。宿主将块6发送给本地结点。状态均为独占。共享集合为{B} |
| CPU A读第12块    | 本地向被替换的宿主结点发写回并修改(A,20)的消息。A将块20写回存储器。之后本地向宿主结点发送读不命中(A,12)消息，宿主结点将块12传送给本地结点。状态均为共享，共享集合为{A} |

执行完后的状态如下:

![](./media/cache-directory.png)

## 四、综合问答

### 1.

- 监听法:

  优：监听协议较为简单，且具有较块的速度

  劣：性能瓶颈取决于总线，总线带宽不足时会影响性能。

- 目录法

  优：多个CPU的大型分布式cache可以稳定运行

  劣：小型体系使用目录法会较为复杂

### 2.

- 异:

  Tomasulo通过寄存器换名来解决WAW，WAR相关。执行前若操作数未准备好则等待。（解决RAW）。且处理和缓存是分布到各个保留站的，是分布式的。而ScoreBoard通过检测是否具有相同的目的（源）寄存器，若有则停止发射（或暂停执行）。且处理和缓存是集中式的。一般而言，Tomasulo效率更高，停顿的周期更少，可以发射更多的指令

- 同：

  都能够通过动态指令流调度的方法来实现乱序执行，一定程度上实现ILP。

### 3.

结构相关：监视保留站。当保留站中对应的功能部件有空闲(非Busy)时再发射对应的指令。

RAW：监视CDB。当操作数就绪（写回CDB）时再开始执行。

WAW,WAR：使用寄存器换名策略。

